{"meta":{"title":"Blog","subtitle":null,"description":null,"author":"yefengyu","url":"http://yefengyu.github.io"},"pages":[],"posts":[{"title":"责任链设计模式","slug":"责任链设计模式","date":"2019-01-30T11:07:31.000Z","updated":"2019-01-30T14:40:33.642Z","comments":true,"path":"2019/01/30/责任链设计模式/","link":"","permalink":"http://yefengyu.github.io/2019/01/30/责任链设计模式/","excerpt":"","text":"概述首先设想这样一个场景，有一个事件流，经过我们系统，会经过多个处理，每一个处理相对比较独立，最后输出结果。如下图所示： 针对上面的场景，我们有如下要求，如果新增一个处理流程，不会对原有的代码进行改动，且事件处理没有先后之分。（注意此处） 责任链处理流程首先在pom.xml文件添加如下依赖，减少对象的getter、setter方法占用页面。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 注意下面使用@Data注解，该注解会提供getter、setter、equals、canEqual、hashCode、toString方法。 1234567891011121314151617181920212223242526package com.yefengyu.design.patterns;import lombok.Data;@Datapublic class Employee&#123; //事件ID private Long id; //员工姓名 private String name; //薪资 private Double salary; //奖金 private Double bonus; //销售量 private Integer salesVolume; //工作年限 private Integer years;&#125; 上面是一个简单的员工对象，根据员工对象的一些信息，给员工计算奖金。假如有以下几条规则： 销售额大于10，奖金加10000 工作满3年，奖金加20000 上面几个规则看起来没什么实际意义，逻辑也很简单。先不要管这些，就认为上面的几个规则：非常复杂、没有任何关联，是合理的，并且规则可能随时添加。 责任链 1234567891011121314151617181920212223242526272829303132333435363738394041package com.yefengyu.design.patterns;import java.util.ArrayList;import java.util.List;public class FilterChain implements Filter&#123; //过滤器列表，实现Filter接口的过滤器将真正执行对事件的处理 private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); //过滤器列表的索引 private int index = 0; //向责任链中加入过滤器（单个） public FilterChain addFilter(Filter filter) &#123; this.filters.add(filter); return this; &#125; //向责任链中加入过滤器（多个） public FilterChain addFilters(List&lt;Filter&gt; filters) &#123; this.filters.addAll(filters); return this; &#125; //处理事件（employee）从FilterChain中获取过滤器，进行处理，处理完成之后过滤器会再调用该方法，继续执行下一个filter.这就需要在每个Filter接口的实现类中最后一句需要回调FilterChain的doFilter方法。 @Override public void doFilter(Employee employee, FilterChain chain) &#123; if (index == filters.size()) &#123; return; &#125; Filter filter = filters.get(index); index++; filter.doFilter(employee, chain); &#125;&#125; 过滤器 123456package com.yefengyu.design.patterns;public interface Filter&#123; void doFilter(Employee employee, FilterChain chain);&#125; 规则1：销售额大于10，奖金加10000 1234567891011121314151617package com.yefengyu.design.patterns;public class Rule1 implements Filter&#123; @Override public void doFilter(Employee employee, FilterChain chain) &#123; //具体逻辑，实际项目应该很复杂 if(employee.getSalesVolume() &gt; 10) &#123; employee.setBonus(employee.getBonus() + 10000); &#125; //注意回调FilterChain的doFilter方法，让FilterChain继续执行下一个Filter chain.doFilter方法，让(employee, chain); &#125;&#125; 工作满3年，奖金加20000 1234567891011121314151617package com.yefengyu.design.patterns;public class Rule2 implements Filter&#123; @Override public void doFilter(Employee employee, FilterChain chain) &#123; //具体逻辑，实际项目应该很复杂 if(employee.getYears() &gt;= 3) &#123; employee.setBonus(employee.getBonus() + 20000); &#125; //注意回调FilterChain的doFilter方法，让FilterChain继续执行下一个Filter chain.doFilter(employee, chain); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; //1,构造事件 Employee employee = new Employee(); employee.setSalary(13456.56); employee.setBonus(5256.2); employee.setSalesVolume(12); employee.setId(1L); employee.setYears(5); employee.setName(\"tom\"); System.out.println(employee); //2,将规则过滤器加入责任链中 FilterChain filterChain = new FilterChain(); filterChain.addFilter(new Rule1()).addFilter(new Rule2()); //3,预处理 //4,执行规则 filterChain.doFilter(employee, filterChain); //5,后处理 System.out.println(employee); &#125;&#125; 结果 Employee{id=1, name=’tom’, salary=13456.56, bonus=5256.2, salesVolume=12, years=5}Employee{id=1, name=’tom’, salary=13456.56, bonus=35256.2, salesVolume=12, years=5} 上面的代码已经是使用责任链来完成了功能，如果我们想添加一个规则，只需实现Filter接口，并且重写doFilter方法，将新添加的规则过滤器加入责任链中即可。也就是： 实现Filter接口并重写doFilter方法 客户端添加该规则过滤器 1filterChain.addFilter(new Rule1()).addFilter(new Rule2()); 举例：加如又加了一个规则Rule3，将年满5年，并且销售量达到20以上的，再加工资10000元。 123456789101112131415package com.yefengyu.design.patterns;public class Rule3 implements Filter&#123; @Override public void doFilter(Employee employee, FilterChain chain) &#123; if(employee.getYears() &gt;= 5 &amp;&amp; employee.getSalesVolume() &gt; 20) &#123; employee.setSalary(employee.getSalary() + 10000); &#125; chain.doFilter(employee, chain); &#125;&#125; 将规则过滤器加入到责任链中： 1234567891011121314151617181920212223242526272829package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; //1,构造事件 Employee employee = new Employee(); employee.setSalary(13456.56); employee.setBonus(5256.2); employee.setSalesVolume(22); employee.setId(1L); employee.setYears(5); employee.setName(\"tom\"); System.out.println(employee); //2,将规则加入责任链中 FilterChain filterChain = new FilterChain(); filterChain.addFilter(new Rule1()).addFilter(new Rule2()).addFilter(new Rule3()); //3,预处理 //4,执行规则 filterChain.doFilter(employee, filterChain); //5,后处理 System.out.println(employee); &#125;&#125; 注意上面的 1filterChain.addFilter(new Rule1()).addFilter(new Rule2()).addFilter(new Rule3()); 以及 1employee.setSalesVolume(22); 这些条件符合规则3的逻辑，那么该员工再加工资10000元。 Employee{id=1, name=’tom’, salary=13456.56, bonus=5256.2, salesVolume=22, years=5}Employee{id=1, name=’tom’, salary=23456.559999999998, bonus=35256.2, salesVolume=22, years=5} 上面完成了我们开始的预想，如果添加规则，不需要在原有的规则基础修改，而是新添加一个规则，并且加入到责任链中，这样就可以执行对应的规则，不过我们想，有时候，我们并不想显示的将规则加入到责任链，我们只需要继承接口即可自动加入到责任链，这样可以把核心逻辑与规则分开。通过注解即可完成这项功能。 责任链和注解配合使用 自定义注解 1234567891011121314package com.yefengyu.design.patterns;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface EnableFilter&#123; public String value() default \"\";&#125; 在每个规则上面都加上EnableFilter注解。 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.reflections&lt;/groupId&gt; &lt;artifactId&gt;reflections&lt;/artifactId&gt; &lt;version&gt;0.9.10&lt;/version&gt;&lt;/dependency&gt; 扫描注解修饰的类，并将这些类实例化返回 123456789101112131415161718192021222324252627282930313233package com.yefengyu.design.patterns;import org.reflections.Reflections;import java.util.ArrayList;import java.util.List;import java.util.Set;public class FilterFactory&#123; public static List&lt;Filter&gt; getFilters(String packages) &#123; List&lt;Filter&gt; filterList = new ArrayList&lt;&gt;(); //通过注解扫描指定的包 Reflections reflections = new Reflections(packages); //如果该包下面有被EnableFilter注解修饰的类，那么将该类的实例加入到列表中，并最终返回 Set&lt;Class&lt;?&gt;&gt; filters = reflections.getTypesAnnotatedWith(EnableFilter.class); for(Class filter : filters) &#123; try &#123; filterList.add((Filter)filter.newInstance()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return filterList; &#125;&#125; 客户端代码 1234567891011121314151617181920212223242526272829package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; //1,构造事件 Employee employee = new Employee(); employee.setSalary(13456.56); employee.setBonus(5256.2); employee.setSalesVolume(22); employee.setId(1L); employee.setYears(5); employee.setName(\"tom\"); System.out.println(employee); //2,将规则加入责任链中,通过注解扫描指定的包 FilterChain filterChain = new FilterChain(); filterChain.addFilters(FilterFactory.getFilters(\"com.yefengyu.design.patterns\")); //3,预处理 //4,执行规则 filterChain.doFilter(employee, filterChain); //5,后处理 System.out.println(employee); &#125;&#125; 上面客户端的责任链并没有手动添加规则过滤器的实现类，通过FilterFactory自动扫描指定的包下面的被EnableFilter注解修饰的类，这样达到了动态添加规则，又不影响主题代码的效果。 如果想排除某些规则该怎么办？ 不能直接修改规则代码，将注解去除 需要使用配置文件，修改工具类，读取配置文件的内容，然后去除对应的过滤器","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yefengyu.github.io/tags/设计模式/"}]}]}