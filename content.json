{"meta":{"title":"Blog","subtitle":null,"description":null,"author":"yefengyu","url":"http://yefengyu.github.io"},"pages":[],"posts":[{"title":"初试Spring-Cloud-Gateway","slug":"初试Spring-Cloud-Gateway","date":"2019-02-15T13:13:50.000Z","updated":"2019-02-15T14:49:52.769Z","comments":true,"path":"2019/02/15/初试Spring-Cloud-Gateway/","link":"","permalink":"http://yefengyu.github.io/2019/02/15/初试Spring-Cloud-Gateway/","excerpt":"","text":"概述 什么是Spring Cloud Gateway Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。 提供依赖 Spring Cloud Gateway需要netty运行环境，由Spring Boot 和 Spring Webflux提供。它无法运行在Servlet 容器中，因此无法打成WAR包。 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如果已经添加了依赖，但是由于一些原因，你不想使用Spring Cloud Gateway，可以使用 spring.cloud.gateway.enabled=false 重要概念 路由：Gateway的基础构建模块。它包括一个ID，一个目标URL，一个断言集合和一个过滤器集合。如果断言判断为真，则路由匹配。 断言：这是Java8的新增功能，输入的类型为Spring框架的ServerWebExchange。它可以匹配HTTP请求中的任何东西，比如：请求头或者参数。 过滤器：是Spring框架的GatewayFilter，请求和响应都可以被Filter修改。 如何工作 在路由中没有指定端口，HTTP将被指定为80，HTTPS 将被指定为443。 构建服务端构建一个spring mvc程序，不做具体介绍 123456789@RestControllerpublic class HelloController&#123; @RequestMapping(\"/hello\") public String hello() &#123; return \"hello: spring-cloud-gateway\"; &#125;&#125; 运行如下图： 构建网关 添加依赖 （概述中第二节，注意是Spring boot工程） 添加端口 为网关项目加入配置文件application.yml，修改服务器端口为9000，配置文件内容如下： 12server: port: 9000 配置网关 12345678910111213spring: application: name: gateway_server cloud: gateway: default-filters: routes: - id: my_route uri: http://localhost:8080/ predicates: - Path=/gateway/** filters: - StripPrefix=1 启动服务，测试 总结 id：固定，不同 id 对应不同的功能 uri：目标服务地址 predicates：路由条件 filters：过滤规则 上面的配置说明： 访问 http://localhost:9000/gateway 路由到 http://localhost:8080 访问 http://localhost:9000/gateway/hello 路由到 http://localhost:8080/hello","categories":[{"name":"Spring Cloud Gateway","slug":"Spring-Cloud-Gateway","permalink":"http://yefengyu.github.io/categories/Spring-Cloud-Gateway/"}],"tags":[{"name":"网关","slug":"网关","permalink":"http://yefengyu.github.io/tags/网关/"},{"name":"微服务","slug":"微服务","permalink":"http://yefengyu.github.io/tags/微服务/"}]},{"title":"JVM内存结构","slug":"JVM内存结构","date":"2019-02-11T12:30:33.000Z","updated":"2019-02-11T15:11:49.469Z","comments":true,"path":"2019/02/11/JVM内存结构/","link":"","permalink":"http://yefengyu.github.io/2019/02/11/JVM内存结构/","excerpt":"","text":"JVM内存结构简介java虚拟机在执行java程序的过程中，会把它管理的内存划分为若干个不同的数据区域，这些区域用途不一，有的随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据JVM规范，JVM应该被划分为五块区域——即虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。 程序计数器程序计数器可以看做当前线程执行字节码的行号指示器，字节码在工作的时候就是更改程序计数器的值来获取下一条字节码指令。字节码指令如分支、循环、异常处理等等。 为什么程序计数器是线程私有的？ 因为虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何时刻一个处理器只会执行一条线程中的指令，因此为了线程切换后能恢复到正常的执行位置，每条线程都需要有一个独立的程序计数器，所以程序计数器是线程私有的。 如果线程执行的是java方法，线程对应的程序计数器记录的是正在执行虚拟机字节码指令地址； 如果执行的是Native方法，则计数器为undefined 虚拟机栈虚拟机栈描述的是java方法执行的内存模型。每个方法在执行的同时都会创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、方法出口等。 局部变量表： 存放编译时可知的基本数据类类型； 对象引用。 异常情况 线程请求的栈容量超过了虚拟机栈允许的最大栈容量，将抛出StackOverflowError 如果虚拟机栈可以动态扩展，并且尝试申请扩展发现内存不够；或者创建新线程的时候没有足够内存去创建虚拟机栈，则抛出OutOfMemoryError 本地方法栈和虚拟机栈相似，区别是：虚拟机栈为执行java方法服务；而本地方法栈则为虚拟机使用的Native方法服务。 由于虚拟机栈和本地方法栈都是存储线程方法的区域，每个线程都有自己的方法的局部变量等，因此也是线程私有的 java堆对于大多数应用，java 堆是存放对象实例的地方，占用内存最大，所有线程共享，虚拟机启动时创建，是垃圾收集器管理的主要区域。堆在物理空间可以不连续，只要逻辑上连续即可。 如果堆中没有内存分配实例、并且堆无法再扩展时，将会抛出OutOfMemoryError 方法区方法区为各个线程所共享区域，用于存放虚拟机加载的类信息、常量、静态变量等数据。 当方法区无法满足内存分配需求的时候，将会抛出OutOfMemoryError 运行时常量池：这是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载之后进入方法区的运行时常量池中存放。","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"http://yefengyu.github.io/categories/Java虚拟机/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yefengyu.github.io/tags/JVM/"}]},{"title":"Spring依赖注入-入门","slug":"Spring依赖注入-入门","date":"2019-02-10T05:31:34.000Z","updated":"2019-02-10T06:17:55.475Z","comments":true,"path":"2019/02/10/Spring依赖注入-入门/","link":"","permalink":"http://yefengyu.github.io/2019/02/10/Spring依赖注入-入门/","excerpt":"","text":"Spring简介spring是一个开源框架，旨在简化java开发。为了降低java开发的复杂度，spring主要采用了以下4种关键策略： 基于POJO的轻量级和最小侵入性编程 通过依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少样板代码 本节主要是第二点依赖注入（DI）的入门知识。 探索DI任何一个实际应用肯定会有多个类组成，类与类之间的有着千丝万缕的关系，按照传统的做法，每个对象负责管理与自己协做的对象的引用，这将会导致高耦合。 示例1： 123456789public class ObjectA&#123; private ObjectB objectB; public ObjectA() &#123; this.objectB = new ObjectB(); &#125;&#125; 示例1中ObjectA管理了一个和自己协作的对象ObjectB，对象ObjectB的创建是通过构造函数直接写死的方式。这种方式耦合度太高，对象ObjectB的属性只能在构造函数中指定（或者使用默认值），每当创建一个ObjectA，ObjectB都是一样的内容。我们想如果ObjectB有很多属性，创建对象ObjectA的时候可以指定，那么有个方法可以实现，将ObjectB参数化，比如构造函数、setter方法等。 示例2： 123456789public class ObjectA&#123; private ObjectB objectB; public ObjectA(ObjectB objectB) &#123; this.objectB = objectB; &#125;&#125; 示例2代码通过构造方法将ObjectB对象传入，灵活度更高。但是有一点问题也需要注意，ObjectA还是和ObjectB强相关联，如果我们想更改ObjectB的逻辑，那么影响是非常大的。这个时候需要使用接口。 示例3： 123456789public class ObjectA&#123; private InterfaceA interfaceA; public ObjectA(InterfaceA interfaceA) &#123; this.interfaceA = interfaceA; &#125;&#125; 示例3对象ObjectA是和接口InterfaceA绑定到一起，只要实现了该接口的实现类，都可以和ObjectA绑定到一起。上面的ObjectB只要实现InterfaceA接口，那么ObjectB就可以作为ObjectA的构造函数的参数。如果新加一个InterfaceA的实现类ObjectC，那么ObjectC也可以作为ObjectA的构造函数的参数。 如果一个对象只通过接口来表明依赖关系，那么这种依赖就能够在对象本身毫不知情的情况下，用不同的具体实现类进行替换。 入门程序下面的入门程序和上面示例2类似，为了简单，暂时没有使用接口。 创建maven工程，添加如下依赖 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yfy.spring&lt;/groupId&gt; &lt;artifactId&gt;spring-project&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 新建一个类Programmer 12345678910111213141516package com.yefengyu.spring;public class Programmer&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 新建一个类Company 12345678910111213141516171819202122232425262728package com.yefengyu.spring;public class Company&#123; private String name; private Programmer programmer; public Company(Programmer programmer) &#123; this.programmer = programmer; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void hello() &#123; System.out.println(\"hello: \" + name + \" 's \" + programmer.getName()); &#125;&#125; Company持有Programmer对象，并且有一个方法hello。 传统方式使用对象 12345678910111213package com.yefengyu.spring;public class Client&#123; public static void main(String[] args) &#123; Programmer programmer = new Programmer(); programmer.setName(\"yefengyu\"); Company company = new Company(programmer); company.setName(\"google\"); company.hello(); &#125;&#125; 传统方式下，使用Company需要先生成Programmer对象作为其属性。programmer和company都是显示创建，并且依赖关系也是在代码中显示指定。 Spring依赖注入方式使用对象 建立一个spring的配置文件application.xml 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"company\" class=\"com.yefengyu.spring.Company\"&gt; &lt;constructor-arg ref=\"programmer\"&gt;&lt;/constructor-arg&gt; &lt;property name=\"name\" value=\"google\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"programmer\" class=\"com.yefengyu.spring.Programmer\"&gt; &lt;property name=\"name\" value=\"yefengyu\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 使用 1234567891011121314package com.yefengyu.spring;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Client&#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(\"application.xml\"); Company company = (Company)ctx.getBean(\"company\"); company.hello(); &#125;&#125; 输出： hello: google ‘s yefengyu 总结 如果Company持有一个接口A，而不是具体的对象，那么所有实现了接口A的实现类（比如Programmer）都可以在xml文件中作为company的一个构造器参数。这样比上面的示例更加接近Spring依赖注入的初衷，使得对象之间耦合度更低。","categories":[{"name":"Spring核心框架","slug":"Spring核心框架","permalink":"http://yefengyu.github.io/categories/Spring核心框架/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yefengyu.github.io/tags/Spring/"},{"name":"IOC","slug":"IOC","permalink":"http://yefengyu.github.io/tags/IOC/"}]},{"title":"简单工厂设计模式","slug":"简单工厂设计模式","date":"2019-02-10T03:34:26.000Z","updated":"2019-02-10T04:23:11.573Z","comments":true,"path":"2019/02/10/简单工厂设计模式/","link":"","permalink":"http://yefengyu.github.io/2019/02/10/简单工厂设计模式/","excerpt":"","text":"定义 简单工厂并不是标准设计模式。 简单工厂设计模式提供一个创建对象实例的功能，而无需关心其具体实现细节。被创建实例的类型可以是接口、抽象类和具体的类。 简单工厂的本质是选择实现，不负责实现具体的功能。 代码示例接口的定义，该接口可以通过简单工厂来创建 123456package com.yfy.test;public interface Api&#123; public void operation(String s);&#125; 接口实现ImplA 12345678910package com.yfy.test;public class ImplA implements Api&#123; @Override public void operation(String s) &#123; System.out.println(\"implA :\" + s); &#125;&#125; 接口实现ImplB 12345678910package com.yfy.test;public class ImplB implements Api&#123; @Override public void operation(String s) &#123; System.out.println(\"implB :\" + s); &#125;&#125; 简单工厂 1234567891011121314151617181920package com.yfy.test;public class Factory&#123; public static Api createApi(int condition) &#123; Api api = null; if(condition == 1) &#123; api = new ImplA(); &#125; else &#123; api = new ImplB(); &#125; return api; &#125;&#125; 客户端使用 12345678910111213package com.yfy.test;public class Client&#123; public static void main(String[] args) &#123; Api api = Factory.createApi(1); api.operation(\"正在使用简单工厂\"); api = Factory.createApi(2); api.operation(\"正在使用简单工厂\"); &#125;&#125; 结果： implA :正在使用简单工厂 implB :正在使用简单工厂 从上面的代码可以看出简单工厂的设计思路，要创建对象，并不用通过new出对象，而是根据工厂代为创建。 接口简介 什么是接口：接口是特殊的抽象类，具体不在这里分析。 用来干什么：通常用接口定义抽象类的外观，就相当于一份契约，根据外部应用需要的功能，约束实现类应该实现的功能。 接口的思想：封装隔离 接口的好处：只要接口不变，内部实现类的变化不会影响外部应用，从而使得系统更加灵活，具有更好的扩展性和可维护性。接口是系统可插拔性的保证。 接口和抽象类：优先选择接口。既要定义子类的行为，又要为子类提供公共的功能时选择抽象类。 面向接口编程接口 123456package com.yfy.test1;public interface Api&#123; public void operation(String s);&#125; 实现类 12345678910package com.yfy.test1;public class Impl implements Api&#123; @Override public void operation(String s) &#123; System.out.println(\"impl :\" + s); &#125;&#125; 客户端使用 1234567891011package com.yfy.test1;public class Client&#123; public static void main(String[] args) &#123; Api api = new Impl(); api.operation(\"调用接口\"); &#125;&#125; 面向接口编程：接口 接口对象 = new 实现类(); 这种模式不是真正的面向接口编程，因为代码中也有实现类。使用简单工厂设计模式就可以解决该问题。如果接口只有一个实现类，那么连condition都不用，这样非常简单，客户只知道Api和Factory，根本不知道实现类。如下节所示 简单工厂(只有一个实现类)接口 123456package com.yfy.test2;public interface Api&#123; public void operation(String s);&#125; 实现类 12345678910package com.yfy.test2;public class Impl implements Api&#123; @Override public void operation(String s) &#123; System.out.println(\"impl :\" + s); &#125;&#125; 工厂 123456789package com.yfy.test2;import com.yfy.test2.Api;public class Factory&#123; public static Api createApi() &#123; return new Impl(); &#125;&#125; 客户端使用 1234567891011package com.yfy.test2;public class Client&#123; public static void main(String[] args) &#123; Api api = Factory.createApi(); api.operation(\"调用接口\"); &#125;&#125; 上面两小节中主要改变是把Api api = new Impl();这句放到简单工厂里面，这和直接调用有什么不同呢？ 理解这个问题主要是理解简单工厂的位置。接口和简单工厂位于封装体内部，但是对外提供调用，外部客户端是不会获得实现类的任何信息。简单工厂真正实现客户端和实现类分割开。 通常把工厂类实现为一个工具类（构造方法私有化），直接使用静态方法（static）就可以，也就是说简单工厂的方法是静态的，所以也称为静态工厂。 简单工厂方法写法简单工厂的方法主要是选择合适的实现类来创建对象，比如第2节代码示例中的Factory类的createApi方法，主要关注这个方法的实现，我们写的思路是如果接口有多个实现类，如何选择，选择一定有条件，根据什么来选择，一般是根据一个参数，那么参数从何而来？ （1）参数来源于客户端，比如第2节代码示例中根据客户端传入的condition来选择。 这种方式有比较大的问题，让客户端传参数，那么客户端必须知道传入参数的含义，哪些是正确的参数、哪些是错误的。此外如果新增实现类就要在工厂中修改代码。 （2）参数来源于配置文件 这个方式一般的形式的是：在配置文件中写入信息（一般是实现类的全限定名），然后代码读取这个配置文件，根据反射的方式创建该实现类的对象。 （3）参数来源于系统，例如运行期间的某个状态。比如计数，当运行奇数和偶数怎么选择等等，这个灵活度比较高。 下面我们使用参数来源于配置文件的形式实现一个简单工厂模式的示例。 参数来源于配置文件实战接口的定义 123456package com.yfy.test;public interface Api&#123; public void operation(String s);&#125; 实现类ImplA 12345678910package com.yfy.test;public class ImplA implements Api&#123; @Override public void operation(String s) &#123; System.out.println(\"implA :\" + s); &#125;&#125; 实现类ImplB 12345678910package com.yfy.test;public class ImplB implements Api&#123; @Override public void operation(String s) &#123; System.out.println(\"implB :\" + s); &#125;&#125; 工厂类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.yfy.test;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class Factory&#123; public static Api createApi() &#123; Properties pros = new Properties(); InputStream in = null; try &#123; in = Factory.class.getResourceAsStream(\"factory.properties\"); pros.load(in); &#125; catch (Exception e) &#123; throw new RuntimeException(\"加载factory.properties文件失败\"); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Api api = null; try &#123; api = (Api) Class.forName(pros.getProperty(\"className\")).newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException(\"获取className失败\"); &#125; return api; &#125;&#125; factory.properties文件 12#className=com.yfy.test.ImplAclassName=com.yfy.test.ImplB 客户端 12345678910package com.yfy.test;public class Client&#123; public static void main(String[] args) &#123; Api api = Factory.createApi(); api.operation(\"正在使用简单工厂\"); &#125;&#125; 此时在客户端就没有选择的过程，选择的过程在配置文件中实现。这个时候如果新添加一个实现类，那么只需要在配置文件中修改即可，不会在工厂方法中修改代码。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yefengyu.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yefengyu.github.io/tags/设计模式/"}]},{"title":"模板设计模式","slug":"模板设计模式","date":"2019-01-31T15:07:20.000Z","updated":"2019-02-10T02:10:01.422Z","comments":true,"path":"2019/01/31/模板设计模式/","link":"","permalink":"http://yefengyu.github.io/2019/01/31/模板设计模式/","excerpt":"","text":"概述定义 定义一个操作中的算法骨架，将步骤延迟到子类中。 模板设计模式是一种行为设计模式，一般是准备一个抽象类，将部分逻辑以具体方法或者具体的构造函数实现，然后声明一些抽象方法，这样可以强制子类实现剩余的逻辑。不同的子类以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板设计模式能达成的功能。 场景 适用于一些复杂操作进行步骤分割、抽取公共部分由抽象父类实现、将不同的部分在父类中定义抽象实现、而将具体实现过程由子类完成。对于整体步骤很固定，但是某些部分易变，可以将易变的部分抽取出来，供子类实现。 模式角色 抽象类：实现模板方法、定义算法骨架 具体类：实现抽象类中的抽象方法，完成特定的算法 举例12345678910111213141516171819202122232425262728293031package com.yefengyu.design.patterns;public abstract class AbstractClass&#123; protected AbstractClass() &#123; System.out.println(\"abstract class's constructor!\"); &#125; public void execute() &#123; concreteOperation1(); abstractOperation1(); abstractOperation2(); concreteOperation2(); &#125; private void concreteOperation1() &#123; System.out.println(\"abstract class's concrete operation 1\"); &#125; private void concreteOperation2() &#123; System.out.println(\"abstract class's concrete operation 2\"); &#125; protected abstract void abstractOperation1(); protected abstract void abstractOperation2();&#125; 上面这段代码中，定义了抽象类AbstractClass，它有一个构造函数，完成某些功能，也有两个具体的方法（concreteOperation1、concreteOperation2），这些方法最好定义成私有，两个抽象方法（abstractOperation1、abstractOperation2）这些方法定义成protected，让子类实现。而execute方法则可以当作算法 框架的入口方法。如果我们定义不同的实现类，那么必然要实现两个抽象方法，那么execute方法的执行算法也会跟着改变，但是总体的算法框架执行流程是不变的。这就是模板设计模式的精髓。 下面我们来编写两个实现类： 12345678910111213141516package com.yefengyu.design.patterns;public class ConcreteClassA extends AbstractClass&#123; @Override protected void abstractOperation1() &#123; System.out.println(\"ConcreteClassA's abstractOperation1\"); &#125; @Override protected void abstractOperation2() &#123; System.out.println(\"ConcreteClassA's abstractOperation2\"); &#125;&#125; 12345678910111213141516package com.yefengyu.design.patterns;public class ConcreteClassB extends AbstractClass&#123; @Override protected void abstractOperation1() &#123; System.out.println(\"ConcreteClassB's abstractOperation1\"); &#125; @Override protected void abstractOperation2() &#123; System.out.println(\"ConcreteClassB's abstractOperation2\"); &#125;&#125; 上面两个实现类中，对两个抽象方法进行实现（过于简单，哈哈），下面写个客户端进行测试： 12345678910111213141516package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; ConcreteClassA concreteClassA = new ConcreteClassA(); concreteClassA.execute(); System.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\"); ConcreteClassB concreteClassB = new ConcreteClassB(); concreteClassB.execute(); &#125;&#125; 测试结果： abstract class’s constructor!abstract class’s concrete operation 1ConcreteClassA’s abstractOperation1ConcreteClassA’s abstractOperation2abstract class’s concrete operation 2$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$abstract class’s constructor!abstract class’s concrete operation 1ConcreteClassB’s abstractOperation1ConcreteClassB’s abstractOperation2abstract class’s concrete operation 2 通过上面的例子，我么可以看出，不同的实现类，重写的抽象方法的逻辑不同，导致算法执行的内容也不相同，但是算法骨架是没有改变的。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yefengyu.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yefengyu.github.io/tags/设计模式/"}]},{"title":"责任链设计模式","slug":"责任链设计模式","date":"2019-01-30T11:07:31.000Z","updated":"2019-02-10T02:16:34.734Z","comments":true,"path":"2019/01/30/责任链设计模式/","link":"","permalink":"http://yefengyu.github.io/2019/01/30/责任链设计模式/","excerpt":"","text":"概述首先设想这样一个场景，有一个事件流，经过我们系统，会执行多个处理逻辑，每一个处理逻辑相对比较独立，最后输出结果。事件流执行过程如下图所示： 针对上面的场景，现在我们有如下要求，如果新增一个处理逻辑，不应该对原有的处理逻辑进行改动，且事件流执行的处理逻辑单元没有先后之分。（注意此处） 责任链实例演示新建一个maven工程，首先在pom.xml文件添加如下依赖，lombok简化开发。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 注意下面使用@Data注解，该注解会提供getter、setter、equals、canEqual、hashCode、toString方法。 1234567891011121314151617181920212223242526package com.yefengyu.design.patterns;import lombok.Data;@Datapublic class Employee&#123; //事件ID private Long id; //员工姓名 private String name; //薪资 private Double salary; //奖金 private Double bonus; //销售量 private Integer salesVolume; //工作年限 private Integer years;&#125; 上面是一个简单的员工对象（当作事件流，每到来一个员工对象，就对该对象进行处理），根据员工对象的一些信息，给员工计算奖金。假如现有以下几条规则： 销售额大于10，奖金加10000 工作满3年，奖金加20000 上面几个规则看起来没什么实际意义，逻辑也很简单。先不要管这些，暂且认为上面的几个规则：非常复杂、没有任何关联、是合理的，并且新规则可能随时添加。 责任链的思想：首先我们要为每一个规则的执行定义一个接口，由实现类具体执行规则，这些规则也就是针对事件（员工）的处理逻辑单元。其次我们要把规则（处理逻辑）关联起来，最简单的办法就是将规则加入到List中，然后循环遍历执行，当然实际中这也是一种方法，下面我们的这种方式，也是先把每个规则加入到List中去，只是执行的时候，有些不同：编写责任链FilterChain，包含List属性和相关方法，将规则（Filter实现类）加入到List中，之后取出一个规则执行，执行规则的业务逻辑方法之后，再回调FilterChain的doFilter，达到循环的目的。 责任链。 12345678910111213141516171819202122232425262728293031323334353637383940package com.yefengyu.design.patterns;import java.util.ArrayList;import java.util.List;public class FilterChain&#123; //规则过滤器列表，实现Filter接口的过滤器将真正执行对事件的处理 private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); //过滤器列表的索引 private int index = 0; //向责任链中加入过滤器（单个） public FilterChain addFilter(Filter filter) &#123; this.filters.add(filter); return this; &#125; //向责任链中加入过滤器（多个） public FilterChain addFilters(List&lt;Filter&gt; filters) &#123; this.filters.addAll(filters); return this; &#125; //处理事件（employee）从FilterChain中获取过滤器，进行处理，处理完成之后过滤器会再调用该方法，继续执行下一个filter.这就需要在每个Filter接口的实现类中最后一句需要回调FilterChain的doFilter方法。 public void doFilter(Employee employee, FilterChain chain) &#123; if (index == filters.size()) &#123; return; &#125; Filter filter = filters.get(index); index++; filter.doFilter(employee, chain); &#125;&#125; 过滤器 123456package com.yefengyu.design.patterns;public interface Filter&#123; void doFilter(Employee employee, FilterChain chain);&#125; 规则1：销售额大于10，奖金加10000 1234567891011121314151617package com.yefengyu.design.patterns;public class Rule1 implements Filter&#123; @Override public void doFilter(Employee employee, FilterChain chain) &#123; //具体逻辑，实际项目应该很复杂 if(employee.getSalesVolume() &gt; 10) &#123; employee.setBonus(employee.getBonus() + 10000); &#125; //注意回调FilterChain的doFilter方法，让FilterChain继续执行下一个Filter chain.doFilter(employee, chain); &#125;&#125; 规则2：工作满3年，奖金加20000 1234567891011121314151617package com.yefengyu.design.patterns;public class Rule2 implements Filter&#123; @Override public void doFilter(Employee employee, FilterChain chain) &#123; //具体逻辑，实际项目应该很复杂 if(employee.getYears() &gt;= 3) &#123; employee.setBonus(employee.getBonus() + 20000); &#125; //注意回调FilterChain的doFilter方法，让FilterChain继续执行下一个Filter chain.doFilter(employee, chain); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; //1,构造事件 Employee employee = new Employee(); employee.setSalary(13456.56); employee.setBonus(5256.2); employee.setSalesVolume(12); employee.setId(1L); employee.setYears(5); employee.setName(\"tom\"); System.out.println(employee); //2,将规则过滤器加入责任链中 FilterChain filterChain = new FilterChain(); filterChain.addFilter(new Rule1()).addFilter(new Rule2()); //3,预处理，具体问题具体对待 //4,执行规则 filterChain.doFilter(employee, filterChain); //5,后处理，具体问题具体对待 System.out.println(employee); &#125;&#125; 结果 Employee{id=1, name=’tom’, salary=13456.56, bonus=5256.2, salesVolume=12, years=5}Employee{id=1, name=’tom’, salary=13456.56, bonus=35256.2, salesVolume=12, years=5} 上面的代码已经是使用责任链来完成了功能，如果我们想新添加一个规则，只需实现Filter接口，并且重写doFilter方法，将新添加的规则过滤器加入责任链中即可。也就是完成以下两步即可： 实现Filter接口并重写doFilter方法 客户端添加该规则过滤器 1filterChain.addFilter(new Rule1()).addFilter(new Rule2()); 举例：假如新加一个规则Rule3，规则内容是将工作年满5年，并且当年销售量达超过20以上的员工的工资上调10000元。 123456789101112131415package com.yefengyu.design.patterns;public class Rule3 implements Filter&#123; @Override public void doFilter(Employee employee, FilterChain chain) &#123; if(employee.getYears() &gt;= 5 &amp;&amp; employee.getSalesVolume() &gt; 20) &#123; employee.setSalary(employee.getSalary() + 10000); &#125; chain.doFilter(employee, chain); &#125;&#125; 将规则过滤器加入到责任链中： 1234567891011121314151617181920212223242526272829package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; //1,构造事件 Employee employee = new Employee(); employee.setSalary(13456.56); employee.setBonus(5256.2); employee.setSalesVolume(22);//注意此处为了满足规则3，已经上调销售量 employee.setId(1L); employee.setYears(5); employee.setName(\"tom\"); System.out.println(employee); //2,将规则加入责任链中，注意新加了Rule3 FilterChain filterChain = new FilterChain(); filterChain.addFilter(new Rule1()).addFilter(new Rule2()).addFilter(new Rule3()); //3,预处理 //4,执行规则 filterChain.doFilter(employee, filterChain); //5,后处理 System.out.println(employee); &#125;&#125; 注意上面的filterChain添加了Rule3 1filterChain.addFilter(new Rule1()).addFilter(new Rule2()).addFilter(new Rule3()); 以及销售量上调以满足Rule3 1employee.setSalesVolume(22); 这些条件符合规则3的逻辑，那么该员工再加工资10000元。 Employee{id=1, name=’tom’, salary=13456.56, bonus=5256.2, salesVolume=22, years=5}Employee{id=1, name=’tom’, salary=23456.559999999998, bonus=35256.2, salesVolume=22, years=5} 上面代码完成了我们开始的预想，如果新添加规则，不需要在原有规则的基础修改，而是新添加一个规则，并且加入到责任链中，这样就可以执行对应的规则，但是这样也有个问题，我们并不想显示的将规则加入到责任链，如果继承接口即可自动加入到责任链，这样的话可以把核心逻辑与规则分开，其实通过注解即可完成这项需求。 责任链和注解配合使用 自定义注解 1234567891011121314package com.yefengyu.design.patterns;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface EnableFilter&#123; public String value() default \"\";&#125; 在每个规则上面都加上EnableFilter注解。 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.reflections&lt;/groupId&gt; &lt;artifactId&gt;reflections&lt;/artifactId&gt; &lt;version&gt;0.9.10&lt;/version&gt;&lt;/dependency&gt; 扫描注解修饰的类，并将这些类实例对象返回 123456789101112131415161718192021222324252627282930313233package com.yefengyu.design.patterns;import org.reflections.Reflections;import java.util.ArrayList;import java.util.List;import java.util.Set;public class FilterFactory&#123; public static List&lt;Filter&gt; getFilters(String packages) &#123; List&lt;Filter&gt; filterList = new ArrayList&lt;&gt;(); //通过注解扫描指定的包 Reflections reflections = new Reflections(packages); //如果该包下面有被EnableFilter注解修饰的类，那么将该类的实例加入到列表中，并最终返回 Set&lt;Class&lt;?&gt;&gt; filters = reflections.getTypesAnnotatedWith(EnableFilter.class); for(Class filter : filters) &#123; try &#123; filterList.add((Filter)filter.newInstance()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return filterList; &#125;&#125; 客户端代码 1234567891011121314151617181920212223242526272829package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; //1,构造事件 Employee employee = new Employee(); employee.setSalary(13456.56); employee.setBonus(5256.2); employee.setSalesVolume(22); employee.setId(1L); employee.setYears(5); employee.setName(\"tom\"); System.out.println(employee); //2,将规则加入责任链中,通过注解扫描指定的包，此处无需指定执行哪个规则（FIlter的实现类） FilterChain filterChain = new FilterChain(); filterChain.addFilters(FilterFactory.getFilters(\"com.yefengyu.design.patterns\")); //3,预处理 //4,执行规则 filterChain.doFilter(employee, filterChain); //5,后处理 System.out.println(employee); &#125;&#125; 上面客户端的责任链并没有手动添加规则过滤器的实现类，通过FilterFactory自动扫描指定的包下面的被EnableFilter注解修饰的类，这样达到了动态添加规则，又不影响主体代码的效果。 如果想排除某些规则该怎么办？ 不能直接修改规则代码，将注解去除 需要使用配置文件，添加一个工具类，读取配置文件的内容，然后去除对应的过滤器","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yefengyu.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yefengyu.github.io/tags/设计模式/"}]}]}