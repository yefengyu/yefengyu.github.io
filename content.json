{"meta":{"title":"Blog","subtitle":null,"description":null,"author":"yefengyu","url":"http://yefengyu.github.io"},"pages":[],"posts":[{"title":"模板设计模式","slug":"模板设计模式","date":"2019-01-31T15:07:20.000Z","updated":"2019-02-04T05:43:43.672Z","comments":true,"path":"2019/01/31/模板设计模式/","link":"","permalink":"http://yefengyu.github.io/2019/01/31/模板设计模式/","excerpt":"","text":"概述定义 定义一个操作中的算法骨架，将步骤延迟到子类中。 模板设计模式是一种行为设计模式，一般是准备一个抽象类，将部分逻辑以具体方法或者具体的构造函数实现，然后声明一些抽象方法，这样可以强制子类实现剩余的逻辑。不同的子类以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板设计模式能达成的功能。 场景 适用于一些复杂操作进行步骤分割、抽取公共部分由抽象父类实现、将不同的部分在父类中定义抽象实现、而将具体实现过程由子类完成。对于整体步骤很固定，但是某些部分易变，可以将易变的部分抽取出来，供子类实现。 模式角色 抽象类：实现模板方法、定义算法骨架 具体类：实现抽象类中的抽象方法，完成特定的算法 举例12345678910111213141516171819202122232425262728293031package com.yefengyu.design.patterns;public abstract class AbstractClass&#123; protected AbstractClass() &#123; System.out.println(\"abstract class's constructor!\"); &#125; public void execute() &#123; concreteOperation1(); abstractOperation1(); abstractOperation2(); concreteOperation2(); &#125; private void concreteOperation1() &#123; System.out.println(\"abstract class's concrete operation 1\"); &#125; private void concreteOperation2() &#123; System.out.println(\"abstract class's concrete operation 2\"); &#125; protected abstract void abstractOperation1(); protected abstract void abstractOperation2();&#125; 上面这段代码中，定义了抽象类AbstractClass，它有一个构造函数，完成某些功能，也有两个具体的方法（concreteOperation1、concreteOperation2），这些方法最好定义成私有，两个抽象方法（abstractOperation1、abstractOperation2）这些方法定义成protected，让子类实现。而execute方法则可以当作算法 框架的入口方法。如果我们定义不同的实现类，那么必然要实现两个抽象方法，那么execute方法的执行算法也会跟着改变，但是总体的算法框架执行流程是不变的。这就是模板设计模式的精髓。 下面我们来编写两个实现类： 12345678910111213141516package com.yefengyu.design.patterns;public class ConcreteClassA extends AbstractClass&#123; @Override protected void abstractOperation1() &#123; System.out.println(\"ConcreteClassA's abstractOperation1\"); &#125; @Override protected void abstractOperation2() &#123; System.out.println(\"ConcreteClassA's abstractOperation2\"); &#125;&#125; 12345678910111213141516package com.yefengyu.design.patterns;public class ConcreteClassB extends AbstractClass&#123; @Override protected void abstractOperation1() &#123; System.out.println(\"ConcreteClassB's abstractOperation1\"); &#125; @Override protected void abstractOperation2() &#123; System.out.println(\"ConcreteClassB's abstractOperation2\"); &#125;&#125; 上面两个实现类中，对两个抽象方法进行实现（过于简单，哈哈），下面写个客户端进行测试： 12345678910111213141516package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; ConcreteClassA concreteClassA = new ConcreteClassA(); concreteClassA.execute(); System.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\"); ConcreteClassB concreteClassB = new ConcreteClassB(); concreteClassB.execute(); &#125;&#125; 测试结果： abstract class’s constructor!abstract class’s concrete operation 1ConcreteClassA’s abstractOperation1ConcreteClassA’s abstractOperation2abstract class’s concrete operation 2$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$abstract class’s constructor!abstract class’s concrete operation 1ConcreteClassB’s abstractOperation1ConcreteClassB’s abstractOperation2abstract class’s concrete operation 2","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yefengyu.github.io/tags/设计模式/"}]},{"title":"责任链设计模式","slug":"责任链设计模式","date":"2019-01-30T11:07:31.000Z","updated":"2019-01-31T15:04:21.048Z","comments":true,"path":"2019/01/30/责任链设计模式/","link":"","permalink":"http://yefengyu.github.io/2019/01/30/责任链设计模式/","excerpt":"","text":"概述首先设想这样一个场景，有一个事件流，经过我们系统，会执行多个处理逻辑，每一个处理逻辑相对比较独立，最后输出结果。事件流执行过程如下图所示： 针对上面的场景，现在我们有如下要求，如果新增一个处理逻辑，不应该对原有的处理逻辑进行改动，且事件流执行的处理逻辑单元没有先后之分。（注意此处） 责任链实例演示新建一个maven工程，首先在pom.xml文件添加如下依赖，lombok简化开发。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 注意下面使用@Data注解，该注解会提供getter、setter、equals、canEqual、hashCode、toString方法。 1234567891011121314151617181920212223242526package com.yefengyu.design.patterns;import lombok.Data;@Datapublic class Employee&#123; //事件ID private Long id; //员工姓名 private String name; //薪资 private Double salary; //奖金 private Double bonus; //销售量 private Integer salesVolume; //工作年限 private Integer years;&#125; 上面是一个简单的员工对象（当作事件流，每到来一个员工对象，就对该对象进行处理），根据员工对象的一些信息，给员工计算奖金。假如现有以下几条规则： 销售额大于10，奖金加10000 工作满3年，奖金加20000 上面几个规则看起来没什么实际意义，逻辑也很简单。先不要管这些，暂且认为上面的几个规则：非常复杂、没有任何关联、是合理的，并且新规则可能随时添加。 责任链的思想：首先我们要为每一个规则的执行定义一个接口，由实现类具体执行规则，这些规则也就是针对事件（员工）的处理逻辑单元。其次我们要把规则（处理逻辑）关联起来，最简单的办法就是将规则加入到List中，然后循环遍历执行，当然实际中这也是一种方法，下面我们的这种方式，也是先把每个规则加入到List中去，只是执行的时候，有些不同：编写责任链FilterChain，包含List属性和相关方法，将规则（Filter实现类）加入到List中，之后取出一个规则执行，执行规则的业务逻辑方法之后，再回调FilterChain的doFilter，达到循环的目的。 责任链。 12345678910111213141516171819202122232425262728293031323334353637383940package com.yefengyu.design.patterns;import java.util.ArrayList;import java.util.List;public class FilterChain&#123; //规则过滤器列表，实现Filter接口的过滤器将真正执行对事件的处理 private List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); //过滤器列表的索引 private int index = 0; //向责任链中加入过滤器（单个） public FilterChain addFilter(Filter filter) &#123; this.filters.add(filter); return this; &#125; //向责任链中加入过滤器（多个） public FilterChain addFilters(List&lt;Filter&gt; filters) &#123; this.filters.addAll(filters); return this; &#125; //处理事件（employee）从FilterChain中获取过滤器，进行处理，处理完成之后过滤器会再调用该方法，继续执行下一个filter.这就需要在每个Filter接口的实现类中最后一句需要回调FilterChain的doFilter方法。 public void doFilter(Employee employee, FilterChain chain) &#123; if (index == filters.size()) &#123; return; &#125; Filter filter = filters.get(index); index++; filter.doFilter(employee, chain); &#125;&#125; 过滤器 123456package com.yefengyu.design.patterns;public interface Filter&#123; void doFilter(Employee employee, FilterChain chain);&#125; 规则1：销售额大于10，奖金加10000 1234567891011121314151617package com.yefengyu.design.patterns;public class Rule1 implements Filter&#123; @Override public void doFilter(Employee employee, FilterChain chain) &#123; //具体逻辑，实际项目应该很复杂 if(employee.getSalesVolume() &gt; 10) &#123; employee.setBonus(employee.getBonus() + 10000); &#125; //注意回调FilterChain的doFilter方法，让FilterChain继续执行下一个Filter chain.doFilter(employee, chain); &#125;&#125; 规则2：工作满3年，奖金加20000 1234567891011121314151617package com.yefengyu.design.patterns;public class Rule2 implements Filter&#123; @Override public void doFilter(Employee employee, FilterChain chain) &#123; //具体逻辑，实际项目应该很复杂 if(employee.getYears() &gt;= 3) &#123; employee.setBonus(employee.getBonus() + 20000); &#125; //注意回调FilterChain的doFilter方法，让FilterChain继续执行下一个Filter chain.doFilter(employee, chain); &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; //1,构造事件 Employee employee = new Employee(); employee.setSalary(13456.56); employee.setBonus(5256.2); employee.setSalesVolume(12); employee.setId(1L); employee.setYears(5); employee.setName(\"tom\"); System.out.println(employee); //2,将规则过滤器加入责任链中 FilterChain filterChain = new FilterChain(); filterChain.addFilter(new Rule1()).addFilter(new Rule2()); //3,预处理，具体问题具体对待 //4,执行规则 filterChain.doFilter(employee, filterChain); //5,后处理，具体问题具体对待 System.out.println(employee); &#125;&#125; 结果 Employee{id=1, name=’tom’, salary=13456.56, bonus=5256.2, salesVolume=12, years=5}Employee{id=1, name=’tom’, salary=13456.56, bonus=35256.2, salesVolume=12, years=5} 上面的代码已经是使用责任链来完成了功能，如果我们想新添加一个规则，只需实现Filter接口，并且重写doFilter方法，将新添加的规则过滤器加入责任链中即可。也就是完成以下两步即可： 实现Filter接口并重写doFilter方法 客户端添加该规则过滤器 1filterChain.addFilter(new Rule1()).addFilter(new Rule2()); 举例：假如新加一个规则Rule3，规则内容是将工作年满5年，并且当年销售量达超过20以上的员工的工资上调10000元。 123456789101112131415package com.yefengyu.design.patterns;public class Rule3 implements Filter&#123; @Override public void doFilter(Employee employee, FilterChain chain) &#123; if(employee.getYears() &gt;= 5 &amp;&amp; employee.getSalesVolume() &gt; 20) &#123; employee.setSalary(employee.getSalary() + 10000); &#125; chain.doFilter(employee, chain); &#125;&#125; 将规则过滤器加入到责任链中： 1234567891011121314151617181920212223242526272829package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; //1,构造事件 Employee employee = new Employee(); employee.setSalary(13456.56); employee.setBonus(5256.2); employee.setSalesVolume(22);//注意此处为了满足规则3，已经上调销售量 employee.setId(1L); employee.setYears(5); employee.setName(\"tom\"); System.out.println(employee); //2,将规则加入责任链中，注意新加了Rule3 FilterChain filterChain = new FilterChain(); filterChain.addFilter(new Rule1()).addFilter(new Rule2()).addFilter(new Rule3()); //3,预处理 //4,执行规则 filterChain.doFilter(employee, filterChain); //5,后处理 System.out.println(employee); &#125;&#125; 注意上面的filterChain添加了Rule3 1filterChain.addFilter(new Rule1()).addFilter(new Rule2()).addFilter(new Rule3()); 以及销售量上调以满足Rule3 1employee.setSalesVolume(22); 这些条件符合规则3的逻辑，那么该员工再加工资10000元。 Employee{id=1, name=’tom’, salary=13456.56, bonus=5256.2, salesVolume=22, years=5}Employee{id=1, name=’tom’, salary=23456.559999999998, bonus=35256.2, salesVolume=22, years=5} 上面代码完成了我们开始的预想，如果新添加规则，不需要在原有规则的基础修改，而是新添加一个规则，并且加入到责任链中，这样就可以执行对应的规则，但是这样也有个问题，我们并不想显示的将规则加入到责任链，如果继承接口即可自动加入到责任链，这样的话可以把核心逻辑与规则分开，其实通过注解即可完成这项需求。 责任链和注解配合使用 自定义注解 1234567891011121314package com.yefengyu.design.patterns;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface EnableFilter&#123; public String value() default \"\";&#125; 在每个规则上面都加上EnableFilter注解。 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.reflections&lt;/groupId&gt; &lt;artifactId&gt;reflections&lt;/artifactId&gt; &lt;version&gt;0.9.10&lt;/version&gt;&lt;/dependency&gt; 扫描注解修饰的类，并将这些类实例对象返回 123456789101112131415161718192021222324252627282930313233package com.yefengyu.design.patterns;import org.reflections.Reflections;import java.util.ArrayList;import java.util.List;import java.util.Set;public class FilterFactory&#123; public static List&lt;Filter&gt; getFilters(String packages) &#123; List&lt;Filter&gt; filterList = new ArrayList&lt;&gt;(); //通过注解扫描指定的包 Reflections reflections = new Reflections(packages); //如果该包下面有被EnableFilter注解修饰的类，那么将该类的实例加入到列表中，并最终返回 Set&lt;Class&lt;?&gt;&gt; filters = reflections.getTypesAnnotatedWith(EnableFilter.class); for(Class filter : filters) &#123; try &#123; filterList.add((Filter)filter.newInstance()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return filterList; &#125;&#125; 客户端代码 1234567891011121314151617181920212223242526272829package com.yefengyu.design.patterns;public class Client&#123; public static void main(String[] args) &#123; //1,构造事件 Employee employee = new Employee(); employee.setSalary(13456.56); employee.setBonus(5256.2); employee.setSalesVolume(22); employee.setId(1L); employee.setYears(5); employee.setName(\"tom\"); System.out.println(employee); //2,将规则加入责任链中,通过注解扫描指定的包，此处无需指定执行哪个规则（FIlter的实现类） FilterChain filterChain = new FilterChain(); filterChain.addFilters(FilterFactory.getFilters(\"com.yefengyu.design.patterns\")); //3,预处理 //4,执行规则 filterChain.doFilter(employee, filterChain); //5,后处理 System.out.println(employee); &#125;&#125; 上面客户端的责任链并没有手动添加规则过滤器的实现类，通过FilterFactory自动扫描指定的包下面的被EnableFilter注解修饰的类，这样达到了动态添加规则，又不影响主体代码的效果。 如果想排除某些规则该怎么办？ 不能直接修改规则代码，将注解去除 需要使用配置文件，添加一个工具类，读取配置文件的内容，然后去除对应的过滤器","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yefengyu.github.io/tags/设计模式/"}]}]}